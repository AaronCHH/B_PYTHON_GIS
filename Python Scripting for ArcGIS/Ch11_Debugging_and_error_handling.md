
# Chapter 11: Debugging and error handling

<!-- toc orderedList:0 depthFrom:1 depthTo:6 -->

* [Chapter 11: Debugging and error handling](#chapter-11-debugging-and-error-handling)
  * [11.1 Introduction](#111-introduction)
  * [11.2 Recognizing syntax errors](#112-recognizing-syntax-errors)
  * [11.3 Recognizing exceptions](#113-recognizing-exceptions)
  * [11.4 Using debugging](#114-using-debugging)
  * [11.5 Using debugging tips and tricks](#115-using-debugging-tips-and-tricks)
  * [11.6 Error handling for exceptions](#116-error-handling-for-exceptions)
  * [11.7 Raising exceptions](#117-raising-exceptions)
  * [11.8 Handling exceptions](#118-handling-exceptions)
  * [11.9 Handling geoprocessing exceptions](#119-handling-geoprocessing-exceptions)
  * [11.10 Using other error-handling methods](#1110-using-other-error-handling-methods)
  * [11.11 Watching for common errors](#1111-watching-for-common-errors)
  * [Points to remember](#points-to-remember)

<!-- tocstop -->


## 11.1 Introduction

This chapter discusses debugging procedures and provides a review of the most common Python errors.
Error-handling procedures are also discussed, including how to get the most out of try - except statements.


No matter how careful you are in writing code, errors are bound to happen.
There are three main types of errors you will encounter in Python: syntax errors , exception, and logic errors.
Syntax errors prevent code from running.
With an exception, a script will stop running midprocess.
A logic error means the script will run but produce undesired results.


## 11.2 Recognizing syntax errors

Syntax errors pertain to spelling, punctuation, and indentation.
Common syntax errors result from misspelled keywords or variables, missing punc tuation, and inconsistent indentation.
See if you can spot the error in the following code:


```python
import arcpy
from arcpy import env
env.workspace = "C:/Data/mydata.gdb"
fclist = arcpy.ListFeatureClasses()
for fc in fclist:
    count = arcpy.GetCount_management(fc)
print count
```


    ---------------------------------------------------------------------------

    TypeError                                 Traceback (most recent call last)

    <ipython-input-4-66917f2ba5f4> in <module>()
          3 env.workspace = "C:/Data/mydata.gdb"
          4 fclist = arcpy.ListFeatureClasses()
    ----> 5 for fc in fclist:
          6     count = arcpy.GetCount_management(fc)
          7 print count


    TypeError: 'NoneType' object is not iterable


## 11.3 Recognizing exceptions

Syntax errors are frustrating, but they are relatively easy to catch com pared to other errors.
Consider the following example that has the syntax corrected:



```python
import arcpy
from arcpy import env
env.workspace = "C:/Data/mydata.gdb"
fclist = arcpy.ListFeatureClasses()
for fc in fclist:
    count = arcpy.GetCount_management(fc)
print count
```


```python

```

## 11.4 Using debugging

When code results in exception errors or logic errors, you may need to look more closely at the values of variables in your script.
This can be accomplished using a debugging procedure.
Debugging is a methodological process for fmding errors in your script.
There are a number of possible debugging procedures, from very basic to more complex.
Debugging proce dures include the following:


* Carefully reviewing the content of error messages
* Adding print statements to your script
* Selectively commenting out code
* Using a Python debugger

Each of these approaches is reviewed in this section in more detail.
Keep in mind that most of the time, debugging does not tell you why a script did not run properly, but it will tell you where - that is, on which line of code it failed.
Typically, you still have to figure out why the error occurred.


* **Carefully reviewing the content of error messages**

Error messages generated by ArcPy are usually informative.
Consider the following example


```python
import arcpy
arcpy.env.workspace = "C:/Data"
infcs = ["streams.shp", "floodzone.shp"]
outfc = "union.shp"
arcpy.Union_analysis(infcs, outfc)
```

This script carries out a union between two input feature classes, which are entered as a list.
The result should be a new output feature class in the same workspace.
The error message in PythonWin is as follows:

ExecuteError : Failed to execute. Parameters are not valid.
ERROR 000366 : Inval geometry type
Failed to execute (Union).

This is a specific error message produced by ArcPy, also referred to as an ExecuteError exception.
The message is useful because it includes the statement: Invalid geometry type .
Closer inspection of the input feature classes reveals that one of the inputs (streams.shp) is a polyline feature class, and the Union tool works with polygon features only.
So the error message does not tell you exactly what is wrong (that is, it did not say that streams.shp is the geometry type polyline and that the Union tool does not accept this geometry type) , but it points you in the right direction.


> **TIP**
When a specific error code is included in the error message, such as ERROR 000366, you can learn more about it in ArcGIS Oesktop Help.
In Help , go to **Geoprocessing > Tool errors and warnings** , and browse to the specific error by number.


Not all error messages are as useful.
Consider the following script:


```python
import arcpy
arcpy.env.workspace = "C:/mydata"
infcs = ["streams.shp", "floodzone.shp"]
outfc = "union.shp"
arcpy.Union_analysis(infcs, outfc)
```

This is, in fact , the same SCl but it uses a different workspace (C: \ mydata) , which do es not exist.
The error m essage in PythonWin is as follows:


* **Adding print statements to your script**

When you have multiple lines of code that contain geoprocessing tools, it may not always be clear on w hich line an error occurred.
In such cases, it may be useful to add print statements after each geoprocessing tool or other important steps to confirm they were run successfully.Consider the following code:



```python
import arcpy
from arcpy import env
env.overwriteOutput = True
env.workspace ="C:/Data"
arcpy.Buffer_analysis("roads.shp", "buffer.shp", "1000 METERS")
print"Buffer completed"
arcpy.Erase_analysis("buffer.shp", "zone.shp", "erase.shp")
print"Erase completed"
arcpy.Clipanalysis("erase.shp", "wetlands.shp", "clip.shp")
print"Clip completed"
```

Even if the error message is cryptic and not informative, the print state ments will illustrate which steps have been completed.
The error can most likely be traced to the block of code just prior to the print statement that did not execute.

Print statements can be effective, but they are most useful when you already have a good idea of what might be causing the error.
One of the downsides of using print statements is that they need to be cleaned up once the error has been fixed , which can be a substantial amount of work.

* **Selectively commenting out code**

You can selectively comment out code to see if removing certain lines elimi nates the error.
If your script has a typical seguential workflow, you would work from the bottom up.
For example , the following code illustrates how the lower lines of code are commented out, using double number signs (##), to isolate the error:



```python
import arc py
from arcpy mport env
env.overwriteOutput True
env.workspace = "C:/Data"
arcpy.Buffer_analysis("roads.shp", "buffer.shp", "1000 METERS")
##arcpy.Erase_ana1ysis("buffer.shp", "streams.shp", "erase.shp")
##arcpy.Clip_analysis("erase.shp", "wetlands.shp", "clip.shp")
```

As with adding print statements, this approach of commenting out lines of code does not identify why an error occurs, but only helps you to isolate where it occurs

* **Using a Python debugger**

Another, more systematic, approach to debugging code is to use a Python debugger.
A debugger is a tool that allows you to step through your code lin e by line, to place breakpoints in your code to examine the conditions at that point, and to follow how certain variables change throughout your code.
Python has a built-in debugger module called pdb .
It is a bit cumber some because it lacks a user interface.
However, Python editors such as IDLE and PythonWin include a solid debugging environment.
In the next example that follows , the PythonWin debugger is used.




```python

```

## 11.5 Using debugging tips and tricks

Following are some general tips and tricks that will help you to debug your scripts:
* Remember that ArcGIS for Desktop applications often place a lock on a file, which may prevent a script from overwriting the file.
* When working with very large files, first try your code on a small file w ith similar properties.
* Watch whe re the values of variables are changing by inserting print statements or breakpoints in the code
* Place breakpoints inside blocks of code where repe tition should be occurring.
* If PythonWin does not stop running while you are debugging, you can interrupt the code by right-clicking the PythonWin icon in the notification area, at the far-right corner of the taskbar, and then clicking "Break into running code".
This will result in a Keyboanterrupt exception in the Interactive Window without closing PythonWin.


## 11.6 Error handling for exceptions

Although debugging procedures can contribute to writing correct code, exception errors are still likely to occur in your scripts.
Exceptions refer to errors that are detected as the script is running.
One key reason for this is that many scripts rely on user input, and you can't always control the input other users will provide.
Well-written scripts, therefore, include error handling procedures to handle exceptions.
Error-handling procedures are written to avoid having a script fail and not provide meaningful feedback.



To handle exceptions, you could use conditional statements to check for certain scenarios, which is analogous to using an if statement.
You have already encountered some in previous chapters.
For example, the existence of a path can be determined in Python using a built-in Python function such as **os.path.exists.**
For catalog paths, you can use the Exists function to determine whether data exists.
For example, the following code determines whether a shapefile exists:


```python
import arcpy
from arcpy import env
env.workspace = "C:/Data"
shape_exist = arcpy.Exists("streams.shp")
print shape_exist
```

The Exists function can be used for feature classes, tables , datasets , shape files, workspaces, layers, and files in the current workspace.
The func tion returns a Boolean value indicating w hether the element exists.



Besides determining whether data exists, you can determine whether the data is the right type by using the Descrbe function.
For example, if your script requires a feature class, you can use the datsetType property to determine w hether it is a feature class.



Writing conditional statements for every possible error is tedious.
And it is impossible to foresee every error.
In the example code earlier in this section, you wo uld have to check the following:
(1) whether the workspace is valid,
(2) whether there is at least one feature class in the workspace, and
(3) whether there is a feature class with at least one feature.
This could easily doub le the code in the script.


There are two strategies to check for errors and report them in a meaningful manner:


1. Use Python exception objects inside try-except statements
2. Report messages using the ArcPy messaging functions.

A powerful alternative to conditional statements is Python exception objects When Python encounters an error, it ises, or throws, an exception.
This typically means the script stops running.
If such an exception object is not handled, or cautht, the script terminates with a runtime error, some times also referred to as a traceback.


## 11.7 Raising exceptions

Exceptions are raised automatically when something goes wrong.
You can also raise exceptions yourself by using the rai se statement.
You can raise a generic exception using the raise excepiton statement, as follows


```python
raise Exception
```


```python
raise Exception("invalid workspace")
```


```python
import exceptions
dir(exceptions)
```


```python
raise ValueError
```

## 11.8 Handling exceptions

Exceptions in a script can be handled using a try-except statement.
Handling exceptions is often called trapping, or catching, the exceptions.
When an exception is properly handled, the script does not produce a runtime error but instead reports a more meaningful error message to the user.
This means the error is trapped, or caught, before it can cause a runtime error


Consider the following script that divides two user-supplied numbers:


```python
x = input("First number: ")
y = input("Second number: ")
print x/y
```

    First number: 1
    Second number: 0



    ---------------------------------------------------------------------------

    ZeroDivisionError                         Traceback (most recent call last)

    <ipython-input-2-887580956abe> in <module>()
          1 x = input("First number: ")
          2 y = input("Second number: ")
    ----> 3 print x/y


    ZeroDivisionError: integer division or modulo by zero



```python
try:
    x = input("First number: ")
    y = input("Second number: ")
    print x/y
except ZeroDivisionError:
    print "The second number cannot be zero."
```

    First number: 1
    Second number: 0
    The second number cannot be zero.



```python
try:
    x = input("First number: ")
    y = input("Second number: ")
    print x/y
except:
    pass
```

    First number: 1
    Second number: 0


Notice the structure of the try-except statement.
The first line of code consists of only the try statement, followed by a colon (:).
Next is a block of indented code with the procedure yo u want to carry out.
Then comes the except statement, which includes a specific exception, followed by a colon (:).
Next is a block of indented code that will be carried out if the spe cific exception is raised.
The exception ZeroDivisionError is a named except√≠on.



In this example, a simple if statement might have been more effec tive to determine whether the value of y is zero (0) .
However, for more elaborate code, you might need many such statements, and a single try-except statement will be sufficient to trap the error

Multiple except statements can be used to catch different named exceptions.
For example:


```python
try:
    x = input("First number: ")
    y = input("Second number: ")
    print x/y
except ZeroDivisionError:
    print "The second number cannot be zero."
except TypeError:
    print "Only numbers are valid entries."
```

    First number: 1
    Second number: 1
    1



```python
try:
    x = input("First number: ")
    y = input("Second number: ")
    print x/y
except (ZeroDivisionError, TypeError):
    print "your entries were not valid."
```

    First number: 1
    Second number: 1
    1



```python
try:
    x = input("First number: ")
    y = input("Second number: ")
    print x/y
except (ZeroDivisionError, TypeError) as e:
    print e
```

    First number: 1
    Second number: 0
    integer division or modulo by zero


It can be difficult som etimes to predict all the typ es of exceptions that might occur.
Esp ecially in a script that relies on user input, yo u m ay not be able to foresee all the possible scenarios .
So to catch all the exceptions, no matter w hat type, you can simply omit the exception class from the except statement, as follows :



```python
try:
    x = input("First number: ")
    y = input("Second number: ")
    print x/y
except Exception as e:
    print e
```

    First number: 1
    Second number: b
    name 'b' is not defined


In this example, the excepti on is unnamed

The try-except statement can also include an else statement, similar
to a conditional statement.
For example:


```python
while True:
    try:
        x = input("First number: ")
        y = input("Second number: ")
        print x/y
    except:
        print "Please try again."
    else:
        break
```

    First number: 1
    Second number: 2.
    0.5


In this example, the try block of code is repeated in a wh le loop w hen an exception is raised.
The loop is broken by the break statement in the else statement only w hen no excep tion is raised.



One more addition to the try- except stateme nt is the finally state m ent.
Whatever the result of previous try , except , or else blocks of code, the fi nally block of code w ill always be executed.
This block typically consists of clean-up tas ks and could include checking in licenses or deleting references to map documents.

## 11.9 Handling geoprocessing exceptions

So far, the exceptions raised have been guite general.
A Python script can, of course, fail for many reasons that are not specifically related to a geopro cessing tool as the previous examples illustrate.
However, because errors related to geoproc ess ing tools are somewhat unusual in nature, they war rant more attention.



You can think of errors as falling into two categories : geoprocessing errors and everything else.
When a geoprocessing tool w rites an error message, ArcPy generates a system error.
Specifically, when a geoprocessing tool fails to it throws an ExecuteError exception , which can be used to handle specific geoprocessing errors.
It is not one of the built-in Python exception classes, but it is generated by ArcPy and thus the arcpy .ExecuteError class has to be used

Consider this example:


```python
import arcpy
arcpy.env.workspace = "C:/Data"
in features = "streams.shp"
out features = "streams.shp"
try:
    arcpy.CopyFeatures_management(in_features, out_features)
except arcpy.ExecuteError:
    print arcpy.GetMessages(2)
except:
    print "There has been a nontool error."
```

The Copy Features tool generates an error because the input and output feature classes cannot be the same, as follows:

In the example code, the first except statement traps any geoprocess ing errors, and the second except statement traps any nongeoprocessing errors.
This example illustrates how both named and unnamed excep tions can be used in the same script.
It is important to first check the named exceptions, such as except arcpy.ExecuteError, and then the unnamed exceptions.
If the unnamed exceptions were checked first, the statement would catch all exceptions, including any arcpy.ExecuteError exceptions.
This would mean yo u wo uld never know w hether a named exception (that you put in the script) occurred or not.



In larger scripts, it can be difficult to determine the precise location of an error.
You can use the Python traceback module to isolate the location and cause of an error.

The traceback structure is as follows:


```python
try:
    import arcpy
    import sys
    import traceback
    <block of code including geoprocessing tools>
except:
    tb = sys.exc_info()[2]
    tbinfo = traceback.format_tb(tb)[0]
    pymsg = "PYTHON ERRORS:\nTraceback info: \n" + tbInfo + "\nErrorInfo : \n" + str (sys.exc_type ) + ":" + str (sys.exc_value) + "\n"
    arcpy.AddError(pymsg)
    msgs = "ArcPy ERRORS:\n" + arcpy.GetMessages(2) + "\n"
    arcpy.AddError(msgs)
    print pymsg + "\n"
    print msgs
```

In this code, two types of errors are trapped: geoprocessing errors and all other types of errors.
The geoprocessing errors are obtained using the ArcPy GetMessages function.
The errors are returned for use in a script too l (AddError ) and also printed to the standard Python output (print).
All other types of errors are ri eved using the traceback module.
Some formatting is applied and the errors are returned for use in a scrip t tool and printed to the standard Python output.


Following is one more example of a try- except statement, using the finally statement.
In this example, a custom exception class is created to handle a license error.
A license is checked out in the try code block and the license is checked in as part of the finally code block.
This ensures the license is checked in, no matter the o utcome of running the earlier code blocks, as follows:



```python
class LicenseError(Exception):
    pass

import arcpy
from arcpy mport env
try:
    if arcpy.CheckExtension("3D") =="Available":
        arcpy.CheckOutExtension("3D")
    else:
        raise LicenseError
    env.workspace = "C:/raster"
    arcpy.Slope_3d("elevation", "slope")
except LicenseError:
    print "3D license is unavailable"
except:
    print arcpy.GetMessages(2)
finally:
    arcpy.CheckInExtension("Spatial")
```

Using the try-except s tatement for error trapping is very common.
The ExecuteError exception class is useful , but in practice, most scripts rely on the simple but effective try-except statement w ithout using specific exception classes.


Some times, you will see an entire script wrapped in a try-except statement.
It would look something like the following structure in w hich the try code block could contain hundreds of lines of code:


```python
try:
    import arcpy
import traceback
## multiple lines of code here
except:
    tb = sys.exc_info()[2]
    tbinf = traceback.format_tb(tb)[0]
    pymsg = "PYTHON ERRORS : \ nTraceback info : \n " + tbinfo + " \ nErrorInfo : \n " + str(sys.exc_info()[1])
    msgs = "Arcpy ERRORS : \n " + arcpy.GetMessages(2) + "\n"
    arcpy.AddError(pymsg)
    arcpy.AddError(msgs)
```

## 11.10 Using other error-handling methods

In addition to a try-except statement for trapping errors in scripts, sev era1 other error-hand1ing methods can be used.
Some of them are covered in ear1ier chapters but warrant further mention here:
* Validating table and field names using the ValidateTableNa me and ValidateFieldName functions, respectively (chapter 7).


* Checking for licenses for products using the CheckProduct function and for extensions using the CheckExtension function (chapter 5)


* Checking for schema locks-many geoprocessing tools will not run properly if schema locks exist on the input.


## 11.11 Watching for common errors

Following are a number of common errors to look out for when you are scanning your scripts and examining your data.

**Common Python code errors**
* Simple spelling mistakes
* Forgetting to import modules, such as arcpy, os, or sys
* Case sensitivity-for example, mylist versus myList
* Paths-for example, using a single backslash (\), such as C:\Data\streams.shp
* Forgetting colons (:) after statements (for, while, else, try, except)
* Incorrect or inconsistent indentation
* Conditional(==) versus assignment(=) statements


**Common geoprocessing-related errors**
* Forgetting to determine whether data exists.
A small typo in the name of a workspace or feature class will cause a tool to fail.
Always double-check that the inputs to a script exist.


* Forgetting to check for overw riting output.
The default setting is not to overwrite outputs, so unless this option is specifically cleared, a tool that attempts to overwrite output will not run.
A very com mon scenario is to run a script and it works, but when you run it a second time, it fails-fixing this could be as simple as setting the overwriteOutput property of the env class to True.


* Data is being used in another application.
You may be trying to run a script, but it will not run because you are also using the data in ArcMap or ArcCatalog-this is very common because often you are exploring the data that is going to be used in the script.
Closing these applications and trying the script again may resolve a script error.


* Not checking the properties of parameters and objects returned by tools.
For example, it may sound logical that the Get Count tool produces a count-that is, a number.
It actually returns a result object that is printed to the Results window, so you have to use the getOutput method to obtain this count.
Similarly, distinctions between feature classes and feature layers may seem somewhat trivial, but they may be just the difference between proper tool execution and failure.
Carefully examine tool syntax and determine the exact nature of the inputs and outputs


It is worth noting that many geoprocessing-related errors can be prevented when using script tools.
Building a script tool includes validation for preventing invalid parameters.
This is covered in chapter 13.


Some of these suggestions may appear rather rudimentary, but the solutions can often be simple if you only knew where to look for them.
The syntax of a good Python geoprocessing script is often relatively simple, which is part of the beauty of using Python.


> **TIP**
Remember that geoprocessing scripts don't have to follow Python coding logic alone.
They must also obey the rules of the ArcGIS geoprocessing framework.


## Points to remember

* Errors in geoprocessing scripts are bound to happen.
Although syntax errors are relatively easy to catch, yo ur script may contain other typ es of errors that prevent proper script execution .
Scripts can be made more robust by incorporating error-handling procedures.


* Various debugging methods exist.
Relatively simple approaches include carefully examining error messages, adding print statements to the code to review intermediate results, and selectively commenting out code.
If these methods are not sufficient to identify and fix errors, a Python debugger can be used such as the PythonWin Debugger.
A debugger allows you to carefully step through the code line by line to review error messages and examine the state of variables.
Breakpoints can be added to step through larger blocks of code.


* Any debugging procedure will typically identify where the error occurs but not exactly why it occurs.
It is therefore good practice to always be aware of common errors, including Python coding errors and ArcGIS geoprocessing errors.


* Basic error-handling procedures include checking whether data exists, determining w hether data inputs are the right type, check ing for licenses and extensions , and validating table and fieldnames.
Typically an if statement is used for this type of error handling.


* It is nearly impossible to anticipate every possible type of errors, and code that checks for such errors wo uld become too cumbersome to write.
Whenever something goes wrong in a sc ri an exception is automatically raised.
These excep tions can be trapped using a try-except statement.
This type of statement makes it possible to identify the type of error or else specific errors.
Customized error-handling procedure can be impl me nt based on the nature of the error.
Additional state ments, including else and finally, can be added to the try-except statement to ensure cient error trapping.


* Error messages can be very useful for identifying the nature of the error and how to fix the script.
These include both general Python messages and error m essages resulting from the ArcPy ExecuteError exception class.



```python

```
